"use client"

import {Button} from "@/components/ui/button"
import {Checkbox} from "@/components/ui/checkbox"
import {getToolName, isToolUIPart, type UIMessage} from "ai"
import React, {useCallback, useEffect, useMemo, useRef, useState} from "react"
import {AnimatePresence, motion} from "framer-motion"
import {toast} from "sonner"

import ProjectOverview from "@/components/project-overview"
import {SessionSelection} from "@/components/chat/session-selection"
import {SessionContextStatus} from "@/components/chat/session-context-status"
import {AssistantMessage} from "@/components/chat/assistant-message"
import {LoadingIndicator} from "@/components/chat/loading-indicator"
import {useCodexChat} from "@/hooks/use-codex-chat"
import {useSessionManager} from "@/hooks/use-session-manager"
import {cn} from "@/lib/utils"

const isAutoGeneratedUserMessage = (message: UIMessage) =>
    Boolean(
        message.role === "user" &&
        (message.metadata as { autoGenerated?: boolean } | undefined)?.autoGenerated,
    )

export default function Chat() {
    const [input, setInput] = useState("")
    const [isExpanded, setIsExpanded] = useState(false)
    const setMessagesRef = useRef<
        | ((
        value: UIMessage[] | ((messages: UIMessage[]) => UIMessage[]),
    ) => void)
        | null
    >(null)
    const promptInputRef = useRef<HTMLDivElement | null>(null)
    const lastAssistantMessageIdRef = useRef<string | null>(null)
    const [globalWriteMode, setGlobalWriteMode] = useState(false)
    const [writeModeSettings, setWriteModeSettings] = useState<Record<string, boolean>>({})
    const [jiraRequestHistory, setJiraRequestHistory] = useState<Record<string, boolean>>({})
    const [persistRequestHistory, setPersistRequestHistory] = useState<Record<string, boolean>>({})
    const [deliveryIntentLog, setDeliveryIntentLog] = useState<
        Array<{
            id: string
            preview: string
            requiresJiraTicket: boolean
            requiresPersistPr: boolean
        }>
    >([])
    const [isJiraTaskRecording, setIsJiraTaskRecording] = useState(false)

    const {
        activeSession,
        fetchSessions,
        handlePersistAction,
        recordJiraTask,
        handleSessionSelect,
        isNewSessionSelection,
        persistActionDisabled,
        persistButtonState,
        persistHelperText,
        selectedBranch,
        selectedProject,
        sessionContextError,
        sessionContextMetadata,
        sessionContextState,
        sessionOptions,
        setBitbucketStatus,
        setSelectedBranch,
        setSelectedProject,
        selectedSessionId,
        refreshPersistState,
        isSessionCreationPending,
    } = useSessionManager({setMessagesRef})

    const detectDeliveryIntent = useCallback(
        async (prompt: string) => {
            if (!activeSession || prompt.trim().length === 0) {
                return
            }
            try {
                const response = await fetch("/api/delivery-intent", {
                    method: "POST",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify({text: prompt}),
                })
                if (!response.ok) {
                    return
                }
                const data = (await response.json()) as {
                    requiresJiraTicket?: boolean
                    requiresPersistPr?: boolean
                }
                if (data.requiresJiraTicket) {
                    setJiraRequestHistory((prev) => {
                        if (prev[activeSession.id]) {
                            return prev
                        }
                        return {...prev, [activeSession.id]: true}
                    })
                }
                if (data.requiresPersistPr) {
                    setPersistRequestHistory((prev) => {
                        if (prev[activeSession.id]) {
                            return prev
                        }
                        return {...prev, [activeSession.id]: true}
                    })
                }
                const logEntry = {
                    id: `${Date.now()}-${Math.random().toString(36).slice(2, 7)}`,
                    preview:
                        prompt.length > 80 ? `${prompt.slice(0, 77).trim()}…` : prompt.trim(),
                    requiresJiraTicket: Boolean(data.requiresJiraTicket),
                    requiresPersistPr: Boolean(data.requiresPersistPr),
                }
                setDeliveryIntentLog((prev) => [logEntry, ...prev].slice(0, 5))
            } catch (error) {
                console.error("Failed to detect delivery intent", error)
            }
        },
        [activeSession],
    )

    const {messages, status, sendMessage, setMessages} = useCodexChat({
        id: activeSession?.id,
        onToolCall({toolCall}) {
            console.log("Tool call:", toolCall)
        },
        onError: () => {
            toast.error("You've been rate limited, please try again later!")
        },
    })
    setMessagesRef.current = setMessages

    useEffect(() => {
        if (messages.length > 0) {
            setIsExpanded(true)
        }
    }, [messages])

    useEffect(() => {
        if (activeSession) {
            setInput("")
        }
    }, [activeSession])

    useEffect(() => {
        setDeliveryIntentLog([])
    }, [activeSession?.id])

    useEffect(() => {
        if (!activeSession) {
            return
        }

        setWriteModeSettings((prev) => {
            if (prev[activeSession.id] !== undefined) {
                return prev
            }
            return {
                ...prev,
                [activeSession.id]: globalWriteMode,
            }
        })

    }, [activeSession, globalWriteMode])

    useEffect(() => {
        if (!activeSession) {
            lastAssistantMessageIdRef.current = null
            return
        }

        const lastAssistant = [...messages]
            .reverse()
            .find((message) => message.role === "assistant")

        if (!lastAssistant) {
            return
        }

        if (lastAssistantMessageIdRef.current === lastAssistant.id) {
            return
        }

        lastAssistantMessageIdRef.current = lastAssistant.id
        void refreshPersistState(activeSession.id)
    }, [messages, activeSession, refreshPersistState])

    const currentToolCall = useMemo(() => {
        const lastAssistant = [...messages]
            .reverse()
            .find((message) => message.role === "assistant")

        if (!lastAssistant) {
            return undefined
        }

        const pendingPart = [...lastAssistant.parts].reverse().find((part) => {
            if (part.type === "dynamic-tool") {
                return part.state !== "output-available" && part.state !== "output-error"
            }

            if (!isToolUIPart(part)) {
                return false
            }

            const toolPart = part as { state?: string }
            return (
                toolPart.state !== "output-available" &&
                toolPart.state !== "output-error"
            )
        })

        if (!pendingPart) {
            return undefined
        }

        if (pendingPart.type === "dynamic-tool") {
            return pendingPart.toolName
        }

        if (isToolUIPart(pendingPart)) {
            return getToolName(pendingPart)
        }

        return undefined
    }, [messages])

    const isAwaitingResponse =
        status === "submitted" || status === "streaming" || currentToolCall != null

    const [showLoading, setShowLoading] = useState(isAwaitingResponse)

    useEffect(() => {
        if (isAwaitingResponse) {
            setShowLoading(true)
            return
        }

        const timeout = setTimeout(() => setShowLoading(false), 120)
        return () => clearTimeout(timeout)
    }, [isAwaitingResponse])

    const canSend =
        activeSession != null &&
        sessionContextState !== "loading" &&
        sessionContextState !== "error" &&
        sessionContextState !== "auth-required"

    const isInputDisabled = !canSend
    const currentSessionId = activeSession?.id ?? null
    const currentWriteMode =
        currentSessionId != null
            ? writeModeSettings[currentSessionId] ?? globalWriteMode
            : globalWriteMode
    const isReadOnlyPrompt = !currentWriteMode
    const userHasRequestedJiraTask =
        currentSessionId != null
            ? Boolean(jiraRequestHistory[currentSessionId])
            : false
    const userHasRequestedPersistPr =
        currentSessionId != null
            ? Boolean(persistRequestHistory[currentSessionId])
            : false
    const userHasRequestedDeliveryAction =
        userHasRequestedJiraTask || userHasRequestedPersistPr
    const sessionHasJiraTask = Boolean(activeSession?.jiraTask?.url)
    const showDeliveryCard =
        !!activeSession &&
        (sessionHasJiraTask || (userHasRequestedDeliveryAction && !isReadOnlyPrompt))
    const isPromptSectionDisabled = sessionContextState === "loading"
    const jiraTicketLabel = activeSession?.jiraTask?.key
        ? `See ticket ${activeSession.jiraTask.key}`
        : "See ticket"
    const persistButtonLabel =
        persistButtonState === "review"
            ? "Review PR"
            : persistButtonState === "update"
                ? "Update PR"
                : "Create PR"

    const handleWriteModeToggle = (checked: boolean) => {
        if (currentSessionId) {
            setWriteModeSettings((prev) => ({
                ...prev,
                [currentSessionId]: checked,
            }))
        } else {
            setGlobalWriteMode(checked)
        }
    }

    const handleReadOnlyToggle = (checked: boolean) => {
        handleWriteModeToggle(!checked)
    }

    const handleCreateJiraTaskAndPersist = useCallback(async () => {
        if (!activeSession) {
            return
        }

        if (persistActionDisabled) {
            toast.error("No persistency layer changes are pending for this session.")
            return
        }

        const urlInput = window
            .prompt("Paste the Jira ticket URL created from this session's scope:")
            ?.trim()

        if (!urlInput) {
            toast.error("A Jira ticket URL is required to continue.")
            return
        }

        let normalizedUrl: string
        try {
            const parsed = new URL(urlInput)
            normalizedUrl = parsed.toString()
        } catch {
            toast.error("Enter a valid Jira ticket URL (https://…)")
            return
        }

        setIsJiraTaskRecording(true)
        try {
            await recordJiraTask(activeSession.id, {url: normalizedUrl})
            toast.success("Jira task saved. Syncing persistency layer…")
            await handlePersistAction()
        } catch (error) {
            console.error("Failed to record Jira task", error)
            toast.error("Unable to record the Jira task. Please try again.")
        } finally {
            setIsJiraTaskRecording(false)
        }
    }, [activeSession, handlePersistAction, persistActionDisabled, recordJiraTask])

    const handleOpenJiraTask = useCallback(() => {
        if (!activeSession?.jiraTask?.url) {
            return
        }

        window.open(activeSession.jiraTask.url, "_blank", "noreferrer")
    }, [activeSession])

    const submitPrompt = useCallback(() => {
        if (!canSend || !activeSession || isPromptSectionDisabled) {
            return
        }
        const trimmedInput = input.trim()
        if (trimmedInput.length === 0) {
            return
        }

        void detectDeliveryIntent(trimmedInput)

        void sendMessage(
            {text: trimmedInput},
            {body: {sessionId: activeSession.id, writeMode: currentWriteMode}},
        )

        setInput("")
        if (promptInputRef.current) {
            promptInputRef.current.innerText = ""
        }
    }, [
        activeSession,
        canSend,
        currentWriteMode,
        input,
        sendMessage,
        isPromptSectionDisabled,
        detectDeliveryIntent,
    ])

    const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
        e.preventDefault()
        submitPrompt()
    }

    const conversationMessages = useMemo(
        () =>
            messages.filter((message) => {
                if (message.role === "assistant") {
                    return true
                }
                if (message.role !== "user") {
                    return false
                }
                return !isAutoGeneratedUserMessage(message)
            }),
        [messages],
    )

    return (
        <div
            className="flex min-h-screen w-full items-start justify-center bg-neutral-100 px-4 py-6 dark:bg-neutral-900">
            <div className="grid w-full max-w-6xl grid-cols-1 gap-6 lg:grid-cols-2">
                <div className="flex flex-col items-center">
                    <ProjectOverview/>
                    <div className="mt-4 flex w-full flex-col gap-3 rounded-lg bg-neutral-200 p-4 dark:bg-neutral-800">
                        <SessionSelection
                            activeSession={activeSession}
                            isNewSessionSelection={isNewSessionSelection}
                            sessionCreationPending={isSessionCreationPending}
                            onBitbucketStatusChange={setBitbucketStatus}
                            onBranchChange={setSelectedBranch}
                            onProjectChange={setSelectedProject}
                            onReloadSessions={fetchSessions}
                            onSessionSelect={handleSessionSelect}
                            selectedBranch={selectedBranch}
                            selectedProject={selectedProject}
                            selectedSessionId={selectedSessionId}
                            sessionOptions={sessionOptions}
                        />

                        <SessionContextStatus
                            state={sessionContextState}
                            metadata={sessionContextMetadata}
                            error={sessionContextError}
                        />
                    </div>
                </div>

                <div
                    className="flex flex-col space-y-4 rounded-lg border border-neutral-200 bg-white/80 p-4 dark:border-neutral-700 dark:bg-neutral-900/60">
                    {deliveryIntentLog.length > 0 && (
                        <div
                            className="rounded-lg border border-dashed border-neutral-200 bg-white p-3 text-xs text-neutral-600 dark:border-neutral-700 dark:bg-neutral-900 dark:text-neutral-300">
                            <p className="text-[11px] uppercase tracking-wide text-neutral-400 dark:text-neutral-500">
                                Delivery intent (last {deliveryIntentLog.length})
                            </p>
                            <div className="mt-2 space-y-2">
                                {deliveryIntentLog.map((entry) => (
                                    <div
                                        key={entry.id}
                                        className="rounded border border-neutral-100 bg-neutral-50 p-2 dark:border-neutral-800 dark:bg-neutral-900/40"
                                    >
                                        <p className="font-medium text-neutral-700 dark:text-neutral-100">
                                            {entry.preview.length > 0
                                                ? entry.preview
                                                : "(empty prompt)"}
                                        </p>
                                        <p>
                                            Jira:{" "}
                                            <span
                                                className={
                                                    entry.requiresJiraTicket
                                                        ? "text-green-600 dark:text-green-400"
                                                        : "text-neutral-500"
                                                }
                                            >
                                                {entry.requiresJiraTicket ? "yes" : "no"}
                                            </span>{" "}
                                            · Persist:{" "}
                                            <span
                                                className={
                                                    entry.requiresPersistPr
                                                        ? "text-green-600 dark:text-green-400"
                                                        : "text-neutral-500"
                                                }
                                            >
                                                {entry.requiresPersistPr ? "yes" : "no"}
                                            </span>
                                        </p>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {showDeliveryCard && (
                        <div
                            className="flex flex-col gap-2 rounded-lg border border-neutral-200 bg-white p-3 dark:border-neutral-700 dark:bg-neutral-900">
                            <div className="flex items-start justify-between gap-3">
                                <div>
                                    <p className="text-sm font-medium text-neutral-700 dark:text-neutral-200">
                                        Delivery workflow
                                    </p>
                                    {sessionHasJiraTask && (
                                        <p className="text-xs text-neutral-500 dark:text-neutral-400">
                                            {activeSession?.jiraTask?.key
                                                ? `Linked ticket ${activeSession.jiraTask.key}`
                                                : "Jira task linked to this session."}
                                        </p>
                                    )}
                                    {sessionHasJiraTask && activeSession?.jiraTask?.summary && (
                                        <p className="text-xs text-neutral-500 dark:text-neutral-400">
                                            {activeSession.jiraTask.summary}
                                        </p>
                                    )}
                                </div>
                                {sessionHasJiraTask ? (
                                    isReadOnlyPrompt ? (
                                        <Button
                                            size="sm"
                                            variant="outline"
                                            onClick={handleOpenJiraTask}
                                        >
                                            {jiraTicketLabel}
                                        </Button>
                                    ) : (
                                        <Button
                                            size="sm"
                                            variant="outline"
                                            disabled={persistActionDisabled}
                                            onClick={handlePersistAction}
                                        >
                                            {persistButtonLabel}
                                        </Button>
                                    )
                                ) : userHasRequestedPersistPr && !userHasRequestedJiraTask ? (
                                    <Button
                                        size="sm"
                                        variant="outline"
                                        disabled={persistActionDisabled}
                                        onClick={handlePersistAction}
                                    >
                                        {persistButtonLabel}
                                    </Button>
                                ) : (
                                    <Button
                                        size="sm"
                                        variant="outline"
                                        disabled={persistActionDisabled || isJiraTaskRecording}
                                        onClick={handleCreateJiraTaskAndPersist}
                                    >
                                        {isJiraTaskRecording
                                            ? "Working..."
                                            : "Create Jira task and PR"}
                                    </Button>
                                )}
                            </div>
                            {sessionHasJiraTask && !isReadOnlyPrompt && (
                                <Button
                                    type="button"
                                    variant="link"
                                    size="sm"
                                    className="w-fit px-0 text-sm font-medium"
                                    onClick={handleOpenJiraTask}
                                >
                                    {jiraTicketLabel}
                                </Button>
                            )}
                            {!isReadOnlyPrompt && persistHelperText && (
                                <p className="text-xs text-neutral-500 dark:text-neutral-400">
                                    {persistHelperText}
                                </p>
                            )}
                        </div>
                    )}

                    <motion.div
                        transition={{type: "spring"}}
                        className="flex max-h-[60vh] flex-col gap-4 overflow-y-auto rounded-lg border border-neutral-200 bg-white/70 p-3 dark:border-neutral-700 dark:bg-neutral-900/60"
                    >
                        <AnimatePresence>
                            {conversationMessages.length === 0 ? (
                                <p className="text-sm text-neutral-500 dark:text-neutral-400">
                                    Start chatting to see responses here.
                                </p>
                            ) : (
                                conversationMessages.map((message) =>
                                    message.role === "assistant" ? (
                                        <div key={message.id}>
                                            <p className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">
                                                Strata
                                            </p>
                                            <AssistantMessage message={message}/>
                                        </div>
                                    ) : (
                                        <div
                                            key={message.id}
                                            className="rounded-lg bg-neutral-100 p-3 text-sm text-neutral-800 dark:bg-neutral-800 dark:text-neutral-100"
                                        >
                                            {message.parts
                                                .filter((part) => part.type === "text")
                                                .map((part) => part?.text)
                                                .join(" ")}
                                        </div>
                                    ),
                                )
                            )}
                        </AnimatePresence>
                        {showLoading && (
                            <div className="border-t border-dashed border-neutral-300 pt-2">
                                <LoadingIndicator tool={currentToolCall ?? undefined}/>
                            </div>
                        )}
                    </motion.div>

                    <form onSubmit={handleSubmit} className="flex flex-col gap-3">
                        <div
                            className={cn(
                                "relative rounded-lg border border-neutral-200 bg-white dark:border-neutral-700 dark:bg-neutral-900",
                                isPromptSectionDisabled && "opacity-60",
                            )}
                            aria-disabled={isPromptSectionDisabled}
                        >
                            {input.length === 0 && (
                                <p className="pointer-events-none select-none text-sm text-neutral-400 dark:text-neutral-500 absolute left-3 top-3">
                                    Ask me anything...
                                </p>
                            )}
                            <div
                                ref={promptInputRef}
                                role="textbox"
                                aria-multiline="true"
                                aria-disabled={isPromptSectionDisabled}
                                contentEditable={!isPromptSectionDisabled}
                                suppressContentEditableWarning
                                tabIndex={isPromptSectionDisabled ? -1 : 0}
                                className={cn(
                                    "max-h-60 min-h-[80px] overflow-y-auto whitespace-pre-wrap p-3 text-sm text-neutral-800 focus:outline-none dark:text-neutral-100",
                                    isPromptSectionDisabled &&
                                    "cursor-not-allowed bg-neutral-50 text-neutral-400 dark:bg-neutral-800 dark:text-neutral-500",
                                )}
                                onInput={(event) => {
                                    if (isPromptSectionDisabled) {
                                        return
                                    }
                                    setInput(event.currentTarget.textContent ?? "")
                                }}
                                onKeyDown={(event) => {
                                    if (isPromptSectionDisabled) {
                                        event.preventDefault()
                                        return
                                    }
                                    if (event.key === "Enter" && !event.shiftKey) {
                                        event.preventDefault()
                                        submitPrompt()
                                    }
                                }}
                            />
                        </div>
                        <div className="flex items-center justify-between">
                            <label className="flex items-center gap-2 text-sm text-neutral-600 dark:text-neutral-300">
                                <Checkbox
                                    checked={isReadOnlyPrompt}
                                    disabled={isPromptSectionDisabled}
                                    onChange={(event) =>
                                        handleReadOnlyToggle(event.target.checked)
                                    }
                                />
                                Read-only prompt
                            </label>
                            <Button
                                type="submit"
                                size="sm"
                                disabled={
                                    isPromptSectionDisabled ||
                                    isInputDisabled ||
                                    input.trim().length === 0
                                }
                            >
                                Send
                            </Button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    )
}
